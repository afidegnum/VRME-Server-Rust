<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `actix_ratelimit` crate."><meta name="keywords" content="rust, rustlang, rust-lang, actix_ratelimit"><title>actix_ratelimit - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../actix_ratelimit/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate actix_ratelimit</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all actix_ratelimit's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'actix_ratelimit', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/actix_ratelimit/lib.rs.html#1-254' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>actix_ratelimit</a></span></h1><div class='docblock'><p>Rate limiting middleware framework for <a href="https://actix.rs/">actix-web</a></p>
<p>This crate provides an asynchronous and concurrent rate limiting middleware based on <a href="https://www.wikiwand.com/en/Actor_model">actor</a>
model which can be wraped around an <a href="https://actix.rs/">Actix</a> application. Middleware contains a store which is used to
identify client request.</p>
<p>Check out the <a href="https://docs.rs/actix-ratelimit/">documentation here</a>.</p>
<p>Comments, suggesstions and critiques are welcomed!</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>Add this to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
actix-ratelimit = &quot;0.2.1&quot;
</code></pre>
<p>Minimal example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">actix_web</span>::{<span class="ident">web</span>, <span class="ident">App</span>, <span class="ident">HttpRequest</span>, <span class="ident">HttpServer</span>, <span class="ident">Responder</span>};
<span class="kw">use</span> <span class="ident">actix_ratelimit</span>::{<span class="ident">RateLimiter</span>, <span class="ident">MemoryStore</span>, <span class="ident">MemoryStoreActor</span>};

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">greet</span>(<span class="ident">req</span>: <span class="ident">HttpRequest</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Responder</span>{
    <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">req</span>.<span class="ident">match_info</span>().<span class="ident">get</span>(<span class="string">&quot;name&quot;</span>).<span class="ident">unwrap_or</span>(<span class="string">&quot;World!&quot;</span>);
    <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;Hello {}!&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">name</span>)
}

<span class="attribute">#[<span class="ident">actix_rt</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Initialize store</span>
    <span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">MemoryStore</span>::<span class="ident">new</span>();
    <span class="ident">HttpServer</span>::<span class="ident">new</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span>{
        <span class="ident">App</span>::<span class="ident">new</span>()
            <span class="comment">// Register the middleware</span>
            <span class="comment">// which allows for a maximum of</span>
            <span class="comment">// 100 requests per minute per client</span>
            <span class="comment">// based on IP address</span>
            .<span class="ident">wrap</span>(
                <span class="ident">RateLimiter</span>::<span class="ident">new</span>(
                <span class="ident">MemoryStoreActor</span>::<span class="ident">from</span>(<span class="ident">store</span>.<span class="ident">clone</span>()).<span class="ident">start</span>())
                    .<span class="ident">with_interval</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">60</span>))
                    .<span class="ident">with_max_requests</span>(<span class="number">100</span>)
            )
            .<span class="ident">route</span>(<span class="string">&quot;/&quot;</span>, <span class="ident">web</span>::<span class="ident">get</span>().<span class="ident">to</span>(<span class="ident">greet</span>))
            .<span class="ident">route</span>(<span class="string">&quot;/{name}&quot;</span>, <span class="ident">web</span>::<span class="ident">get</span>().<span class="ident">to</span>(<span class="ident">greet</span>))
    })
    .<span class="ident">bind</span>(<span class="string">&quot;127.0.0.1:8000&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">run</span>()
    .<span class="kw">await</span>
}</pre></div>
<p>Sending a request returns a response with the ratelimiting headers:</p>
<pre><code class="language-shell">$ curl -i &quot;http://localhost:8000/&quot;

HTTP/1.1 200 OK
content-length: 13
content-type: text/plain; charset=utf-8
x-ratelimit-remaining: 99
x-ratelimit-reset: 52
x-ratelimit-limit: 100
date: Tue, 04 Feb 2020 21:53:27 GMT

Hello World!
</code></pre>
<p>Exceeding the limit returns HTTP 429 Error code.</p>
<h1 id="stores" class="section-header"><a href="#stores">Stores</a></h1>
<p>A <em>store</em> is a data structure, database connection or anything which can be used to store
<em>ratelimit</em> data associated with a <em>client</em>. A <em>store actor</em> which acts on this store is
responsible for performiing all sorts of operations(SET, GET, DEL, etc). It is Important to
note that there are multiple store actors acting on a <em>single</em> store.</p>
<h2 id="supported" class="section-header"><a href="#supported">Supported</a></h2>
<ul>
<li>In-memory (based on concurrent <a href="https://github.com/xacrimon/dashmap">hashmap</a>)</li>
<li>Redis (based on <a href="https://github.com/mitsuhiko/redis-rs">redis-rs</a>)</li>
</ul>
<h2 id="planned" class="section-header"><a href="#planned">Planned</a></h2>
<ul>
<li>Memcached (not yet implemented)</li>
</ul>
<h1 id="implementing-your-own-store" class="section-header"><a href="#implementing-your-own-store">Implementing your own store</a></h1>
<p>To implement your own store, you have to implement an <a href="https://actix.rs/actix/actix/trait.Actor.html">Actor</a> which can handle <a href="enum.ActorMessage.html">ActorMessage</a> type
and return <a href="enum.ActorResponse.html">ActorResponse</a> type. Check the <a href="stores/index.html">module level documentation</a> for
more details and a basic example.</p>
<h1 id="note-to-developers" class="section-header"><a href="#note-to-developers">Note to developers</a></h1>
<ul>
<li>To use redis store, put this to your Cargo.toml:</li>
</ul>
<pre><code class="language-toml">[dependencies]
actix-ratelimit = {version = &quot;0.2.1&quot;, default-features = false, features = [&quot;redis-store&quot;]}
</code></pre>
<ul>
<li>By default, the client's IP address is used as the identifier which can be customized
using <a href="https://docs.rs/actix-web/2.0.0/actix_web/dev/struct.ServiceRequest.html">ServiceRequest</a> instance.
For example, using api key header to identify client:</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">actix_rt</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Initialize store</span>
    <span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">MemoryStore</span>::<span class="ident">new</span>();
    <span class="ident">HttpServer</span>::<span class="ident">new</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span>{
        <span class="ident">App</span>::<span class="ident">new</span>()
            .<span class="ident">wrap</span>(
                <span class="ident">RateLimiter</span>::<span class="ident">new</span>(
                <span class="ident">MemoryStoreActor</span>::<span class="ident">from</span>(<span class="ident">store</span>.<span class="ident">clone</span>()).<span class="ident">start</span>())
                    .<span class="ident">with_interval</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">60</span>))
                    .<span class="ident">with_max_requests</span>(<span class="number">100</span>)
                    .<span class="ident">with_identifier</span>(<span class="op">|</span><span class="ident">req</span><span class="op">|</span> {
                        <span class="kw">let</span> <span class="ident">key</span> <span class="op">=</span> <span class="ident">req</span>.<span class="ident">headers</span>().<span class="ident">get</span>(<span class="string">&quot;x-api-key&quot;</span>).<span class="ident">unwrap</span>();
                        <span class="kw">let</span> <span class="ident">key</span> <span class="op">=</span> <span class="ident">key</span>.<span class="ident">to_str</span>().<span class="ident">unwrap</span>();
                        <span class="prelude-val">Ok</span>(<span class="ident">key</span>.<span class="ident">to_string</span>())
                    })
            )
            .<span class="ident">route</span>(<span class="string">&quot;/&quot;</span>, <span class="ident">web</span>::<span class="ident">get</span>().<span class="ident">to</span>(<span class="ident">greet</span>))
            .<span class="ident">route</span>(<span class="string">&quot;/{name}&quot;</span>, <span class="ident">web</span>::<span class="ident">get</span>().<span class="ident">to</span>(<span class="ident">greet</span>))
    })
    .<span class="ident">bind</span>(<span class="string">&quot;127.0.0.1:8000&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">run</span>()
    .<span class="kw">await</span>
}</pre></div>
<ul>
<li>It is <strong>important</strong> to initialize store before creating HttpServer instance, or else a store
will be created for each web worker. This may lead to instability and inconsistency! For
example, initializing your app in the following manner would create more than one stores:</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">actix_rt</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="ident">HttpServer</span>::<span class="ident">new</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span>{
        <span class="ident">App</span>::<span class="ident">new</span>()
            .<span class="ident">wrap</span>(
                <span class="ident">RateLimiter</span>::<span class="ident">new</span>(
                <span class="ident">MemoryStoreActor</span>::<span class="ident">from</span>(<span class="ident">MemoryStore</span>::<span class="ident">new</span>()).<span class="ident">start</span>())
                    .<span class="ident">with_interval</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">60</span>))
                    .<span class="ident">with_max_requests</span>(<span class="number">100</span>)
            )
            .<span class="ident">route</span>(<span class="string">&quot;/&quot;</span>, <span class="ident">web</span>::<span class="ident">get</span>().<span class="ident">to</span>(<span class="ident">greet</span>))
            .<span class="ident">route</span>(<span class="string">&quot;/{name}&quot;</span>, <span class="ident">web</span>::<span class="ident">get</span>().<span class="ident">to</span>(<span class="ident">greet</span>))
    })
    .<span class="ident">bind</span>(<span class="string">&quot;127.0.0.1:8000&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">run</span>()
    .<span class="kw">await</span>
}</pre></div>
<ul>
<li>The exception is redis, where multiple connections will be
created for each worker. Since redis store is based on Multiplexed connection, sharing once
connection across multiple store actors should suffice for most use cases.</li>
</ul>
<h1 id="status" class="section-header"><a href="#status">Status</a></h1>
<p>This project has not reached v1.0, so some instability and breaking changes are to be expected
till then.</p>
<p>You can use the <a href="https://github.com/TerminalWitchcraft/actix-ratelimit/issues">issue tracker</a> in case you encounter any problems.</p>
<h1 id="license" class="section-header"><a href="#license">LICENSE</a></h1>
<p>This project is licensed under MIT license.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use middleware::<a class="struct" href="../actix_ratelimit/middleware/struct.RateLimiter.html" title="struct actix_ratelimit::middleware::RateLimiter">RateLimiter</a>;</code></td></tr><tr><td><code>pub use stores::memory::<a class="struct" href="../actix_ratelimit/stores/memory/struct.MemoryStore.html" title="struct actix_ratelimit::stores::memory::MemoryStore">MemoryStore</a>;</code></td></tr><tr><td><code>pub use stores::memory::<a class="struct" href="../actix_ratelimit/stores/memory/struct.MemoryStoreActor.html" title="struct actix_ratelimit::stores::memory::MemoryStoreActor">MemoryStoreActor</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="errors/index.html" title='actix_ratelimit::errors mod'>errors</a></td><td class='docblock-short'><p>Errors that can occur during middleware processing stage</p>
</td></tr><tr class='module-item'><td><a class="mod" href="middleware/index.html" title='actix_ratelimit::middleware mod'>middleware</a></td><td class='docblock-short'><p>RateLimiter middleware for actix application</p>
</td></tr><tr class='module-item'><td><a class="mod" href="stores/index.html" title='actix_ratelimit::stores mod'>stores</a></td><td class='docblock-short'><p>Type used to store ratelimiter data associated with a client.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.ActorMessage.html" title='actix_ratelimit::ActorMessage enum'>ActorMessage</a></td><td class='docblock-short'><p>Represents message that can be handled by a <code>StoreActor</code></p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ActorResponse.html" title='actix_ratelimit::ActorResponse enum'>ActorResponse</a></td><td class='docblock-short'><p>Represents data returned in response to <code>Messages</code> by a <code>StoreActor</code></p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.Output.html" title='actix_ratelimit::Output type'>Output</a></td><td class='docblock-short'><p>Wrapper type for <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> type</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "actix_ratelimit";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>