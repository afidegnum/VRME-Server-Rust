//! Handles user registration and account creation.
//!
//! We require that the client supply a *hashed* password from the client-side which shall be
//! generated by a cryptographically-strong hashing function such as `SHA-256` to avoid transferring
//! the plain-text password over the network which could be compromised.
//!
//! # Reference
//!
//! - [SHA-256](https://tools.ietf.org/html/rfc4634)

use crate::database::Pool;
use crate::service_errors::ServiceError;
use actix_web::{web, HttpResponse, ResponseError};
use base64;
use log::debug;
use serde::{Deserialize, Serialize};
use serde_json::json;

/// Required payload when a user wishes to register to create a new account.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RegistrationRequest {
	email: String,
	first_name: String,
	last_name: String,
	/// Must be hashed client-side with a strong hash function such as SHA-256. The hash must be
	/// truncated to 32 bytes, then encoded in Base64, which gives exactly `43` base64 characters.
	hashed_password: String,
}

/// POST endpoint handler for user registration.
///
/// # Endpoint
///
/// - **HTTP Verb**: `POST`
/// - **Payload Required**?: YES
///
/// # Required Headers
///
/// - Content type: `Content-Type: application/json`
/// - Content length: `Content-Length: <JSON_SIZE>` where `<JSON_SIZE>: u32`
///
/// # Required Payload
///
/// Payload format and required fields are specified by `RegistrationRequest`.
///
/// # Example Request
///
/// ```http
/// POST /register HTTP 1.1
/// Content-Type: application/json
/// Content-Length: 135
///
/// {
///     "email": "no-reply@example.com",
///     "first_name": "John",
///     "last_name": "Doe",
///     "hashed_password": "0123456789012345678901234567890123456789012"
/// }
/// ```
///
/// # Errors
///
/// Refer to the API endpoint documentation for possible error responses.
pub async fn handle_registration(
	payload: web::Json<RegistrationRequest>,
	_pool: web::Data<Pool>,
) -> HttpResponse {
	{
		let payload = payload.clone();
		if let Err(e) =
			web::block(move || validate_request_payload(&payload)).await
		{
			debug!("{}", e);
			return ServiceError::InternalServerError(
				"Threading error".to_string(),
			)
			.error_response();
		}
	}

	// TODO: actual registration logic
	make_success_response(&payload.email)
}

fn validate_request_payload(
	payload: &RegistrationRequest,
) -> Result<(), ServiceError> {
	validate_name_length(&payload.first_name, "first_name")?;
	validate_name_length(&payload.last_name, "last_name")?;
	validate_email(&payload.email)?;
	validate_hashed_password(&payload.hashed_password)?;

	Ok(())
}

fn validate_name_length(
	name: &str,
	name_kind: &str,
) -> Result<(), ServiceError> {
	if name.is_empty() {
		return Err(ServiceError::BadRequest(format!(
			"`{}` canot be empty",
			name_kind
		)));
	}

	if name.len() > 100 {
		return Err(ServiceError::BadRequest(format!(
			"`{}` is too long",
			name_kind
		)));
	}

	Ok(())
}

// Only checks that the email has a minimum length of 3 characters and must include `@` character.
fn validate_email(email: &str) -> Result<(), ServiceError> {
	if email.len() < 3 {
		return Err(ServiceError::BadRequest(
			"Invalid email address: too short".to_string(),
		));
	}

	if !email.contains('@') {
		return Err(ServiceError::BadRequest(
			"Invalid email address".to_string(),
		));
	}

	Ok(())
}

fn validate_hashed_password(hashed_password: &str) -> Result<(), ServiceError> {
	// `hahsed_password` *must* be the first 32-bytes of the hash of the raw password. The 32 bytes
	// must then be Base64-encoded into 43 Base64 characters.
	//
	// Each Base64 character can encode 6 bits (`64 == 2^6`), which means that 32 bytes require
	// `Ceil(4/3 * 32) = 43` Base64 characters to encode.
	if hashed_password.len() != 43 {
		return Err(ServiceError::BadRequest(
            "Invalid `hashed_password`: incorrect length {} when 43 is required after 32 bytes of \
            password hash is Base64-encoded".to_string()
        ));
	}

	if let Err(e) = base64::decode(hashed_password) {
		debug!("Invalid `hashed_password`: {}", e.to_string());
		return Err(ServiceError::BadRequest(
            "Invalid `hashed_password`: the provided hash is not a valid Base64-encoded string".to_string()
                ));
	}

	Ok(())
}

fn make_success_response(email: &str) -> HttpResponse {
	let message = json!({
		"message": format!("Account with email {} successfully created", email)
	});

	HttpResponse::Created().json(message)
}
