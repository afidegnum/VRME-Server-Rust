//! Handles user registration and account creation.
//!
//! We require that the client supply a *hashed* password from the client-side which shall be
//! generated by a cryptographically-strong hashing function such as `SHA-256` to avoid transferring
//! the plain-text password over the network which could be compromised.
//!
//! # Reference
//!
//! - [SHA-256](https://tools.ietf.org/html/rfc4634)

use crate::database::ConnectionPool;
use crate::service_errors::ServiceError;
use actix_web::{web, HttpResponse, ResponseError};
use base64;
use deadpool_postgres::Client;
use log::debug;
use rand;
use ring::pbkdf2;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::num::NonZeroU32;
use uuid::Uuid;

/// Length of the extracted hashed password in bytes. This is for the raw hashed password bytes that
/// is not Base64-encoded.
pub const HASHED_PASSWORD_LEN: usize = 32;

/// Must be hashed client-side with a strong hash function such as SHA-256. The hash must be
/// truncated to 32 bytes, then encoded in Base64, which gives exactly **44** base64 characters
/// (43 to encode the 32 bytes and one more additional byte so it rounds up to a multipe of 4).
pub const BASE64_ENCODED_HASHED_PASSWORD_LEN: usize = 44;

/// Length of the randomly generated salt in bytes.
pub const SALT_LEN: usize = 16;

/// We use the `PBKDF2` algorithm to compute the password hash in a secure fashion, with the core
/// hash function being `HMAC-SHA-256`.
///
/// # References
///
/// - [`ring::pbkdf2`](https://briansmith.org/rustdoc/ring/pbkdf2/index.html).
static PBKDF2_ALGORITHM: pbkdf2::Algorithm = pbkdf2::PBKDF2_HMAC_SHA256;

/// Number of `PBKDF2` iterations to perform. The more iterations, the more difficult to try to
/// compute a rainbow table to try to reverse the hash. However, more iterations also take more CPU
/// cycles to compute.
///
/// We default to use `100_000` iterations which gives a reasonably large number of iterations to
/// hinder a possible attacker.
///
/// As computing power increases, the number of iterations should also be increased to ensure the
/// difficulity (in computing time) for an potential adversay to try to compute a rainbow table for
/// the `PBKDF2` + `HMAC-SHA-256` combination.
pub const PBKDF2_ITERATIONS: NonZeroU32 = unsafe {
	// SAFETY: `100_000` is guaranteed to fit within a `u32` AND is not zero.
	NonZeroU32::new_unchecked(100_000)
};

/// Required payload when a user wishes to register to create a new account.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RegistrationRequest {
	pub email: String,
	pub first_name: String,
	pub last_name: String,
	pub hashed_password: String,
}

/// POST endpoint handler for user registration.
///
/// # Endpoint
///
/// - **HTTP Verb**: `POST`
/// - **Payload Required**?: YES
///
/// # Required Headers
///
/// - Content type: `Content-Type: application/json`
/// - Content length: `Content-Length: <JSON_SIZE>` where `<JSON_SIZE>: u32`
///
/// # Required Payload
///
/// Payload format and required fields are specified by `RegistrationRequest`.
///
/// # Example Request
///
/// ```http
/// POST /register HTTP 1.1
/// Content-Type: application/json
/// Content-Length: 135
///
/// {
///     "email": "no-reply@example.com",
///     "first_name": "John",
///     "last_name": "Doe",
///     "hashed_password": "0123456789012345678901234567890123456789012"
/// }
/// ```
///
/// # Errors
///
/// Refer to the API endpoint documentation for possible error responses.
pub async fn handle_registration(
	request_info: web::Json<RegistrationRequest>,
	pool: web::Data<ConnectionPool>,
) -> HttpResponse {
	debug!("Request:\n {:?}", &request_info);

	if let Err(e) = validate_request_payload(request_info.clone()).await {
		debug!("{}", &e);
		return ServiceError::InternalServerError(
			"Threading error".to_string(),
		)
		.error_response();
	}

	// We first need to base64-decode the client password hash.
	let mut client_password_hash = [0u8; HASHED_PASSWORD_LEN];
	if let Err(e) =
		base64_decode(&mut client_password_hash, &request_info.hashed_password)
			.await
	{
		return e.error_response();
	}

	// We then need to compute the `PasswordHashInfo` to store them into the database.
	let password_hash_info = match run_pbkdf2(&mut client_password_hash).await {
		Ok(info) => info,
		Err(e) => {
			debug!("{}", &e);
			return e.error_response();
		}
	};

	let client = match pool.get().await {
		Ok(client) => client,
		Err(e) => {
			debug!("{}", &e);
			return ServiceError::InternalServerError(e.to_string())
				.error_response();
		}
	};

	let (user_id, email) = match create_account_if_not_exists(
		&client,
		&request_info,
		&password_hash_info,
	)
	.await
	{
		Ok((user_id, email)) => (user_id, email),
		Err(e) => {
			debug!("{}", &e);
			return e.error_response();
		}
	};

	make_success_response(&user_id, &email)
}

async fn validate_request_payload(
	payload: RegistrationRequest,
) -> Result<(), ServiceError> {
	web::block(move || {
		validate_name_length(&payload.first_name, "first_name")?;
		validate_name_length(&payload.last_name, "last_name")?;
		validate_email(&payload.email)?;
		validate_hashed_password(&payload.hashed_password)?;
		Ok::<(), ServiceError>(())
	})
	.await
	.map_err(|e| {
		if let actix_web::error::BlockingError::Error(err) = e {
			err
		} else {
			ServiceError::InternalServerError(e.to_string())
		}
	})
}

fn validate_name_length(
	name: &str,
	name_kind: &str,
) -> Result<(), ServiceError> {
	if name.is_empty() {
		return Err(ServiceError::BadRequest(format!(
			"`{}` canot be empty",
			name_kind
		)));
	}

	if name.len() > 100 {
		return Err(ServiceError::BadRequest(format!(
			"`{}` is too long",
			name_kind
		)));
	}

	Ok(())
}

// Only checks that the email has a minimum length of 3 characters and must include `@` character.
fn validate_email(email: &str) -> Result<(), ServiceError> {
	if email.len() < 3 {
		return Err(ServiceError::BadRequest(
			"Invalid email address: too short".to_string(),
		));
	}

	if !email.contains('@') {
		return Err(ServiceError::BadRequest(
			"Invalid email address".to_string(),
		));
	}

	Ok(())
}

fn validate_hashed_password(hashed_password: &str) -> Result<(), ServiceError> {
	// `hahsed_password` *must* be the first 32-bytes of the hash of the raw password. The 32 bytes
	// must then be Base64-encoded into 44 Base64 characters.
	//
	// Each base64 character can encode 6 bits (`64 == 2^6`), which means that 32 bytes require
	// `Ceil(4/3 * 32) = 43` => nearest multiple of 4 is `44` Base64 characters to encode.
	if hashed_password.len() != BASE64_ENCODED_HASHED_PASSWORD_LEN {
		return Err(ServiceError::BadRequest(
			format!(
                "Invalid `hashed_password`: incorrect length {} when {} is required after {} \
                bytes of password hash is base64-encoded",
				hashed_password.len(),
				BASE64_ENCODED_HASHED_PASSWORD_LEN,
				HASHED_PASSWORD_LEN,
			),
		));
	}

	if let Err(e) = base64::decode(hashed_password) {
		debug!("Invalid `hashed_password`: {}", e.to_string());
		return Err(ServiceError::BadRequest(
                "Invalid `hashed_password`: the provided hash is not a valid base64-encoded \
                string".to_string()
            )
        );
	}

	Ok(())
}

async fn base64_decode(
	hashed_password_buffer: &mut [u8; HASHED_PASSWORD_LEN],
	encoded_hashed_password: &str,
) -> Result<(), ServiceError> {
	let bytes = match base64::decode(encoded_hashed_password) {
		Ok(b) => b,
		Err(_) => {
			return Err(ServiceError::BadRequest(
				"Invalid base64 encoding of hashed password".to_string(),
			));
		}
	};

	if bytes.len() != HASHED_PASSWORD_LEN {
		return Err(ServiceError::BadRequest(
			"base64-encoded hashed password has invalid length".to_string(),
		));
	}

	Ok(hashed_password_buffer.copy_from_slice(&bytes))
}

/// `PasswordHashInfo` is derived from the client-side provided `hashed_password`.
pub struct PasswordHashInfo {
	/// Number of iterations of `PBKDF2`.
	pub iteration_count: NonZeroU32,
	/// 16-byte `salt` generated from a secure random number generator.
	pub salt: Vec<u8>,
	/// 32-bytes of the output of `PBKDF2`.
	pub password_hash_final: Vec<u8>,
}

/// Generate `PasswordHashInfo` for secure storage in persistent storage.
///
/// # Password Hash Generation Process
///
/// - We use a **secure random number generator** to generate a \\( 16 \\) byte
///   `salt`.
/// - We feed the `salt` and `password_hashed_1` into **PBKDF2**.
/// - We initialize **PBKDF2** with **HMAC-SHA-256** as the core hash function.
/// - We perform `100,000` iterations (`iteration_count = 100_000`).
/// - We take `32` bytes (`256` bits) of the output of **PBKDF2** as the final
///   `password_hash_final`.
pub async fn run_pbkdf2(
	client_hash: &mut [u8; HASHED_PASSWORD_LEN],
) -> Result<PasswordHashInfo, ServiceError> {
	use rand::RngCore;

	let client_hash = client_hash.clone();

	// Because hash computations are costly, we delegate such expensive computation in a new thread
	// as to not block the response handler thread. Exactly how this is scheduled is up to `tokio`
	// and its runtime async scheduling.
	web::block(move || {
		let mut salt = [0u8; SALT_LEN];

		if let Err(e) = rand::thread_rng().try_fill_bytes(&mut salt) {
			debug!("{}", &e);
			return Err::<PasswordHashInfo, ServiceError>(
				ServiceError::InternalServerError(
					"Failed to generate password salt".to_string(),
				),
			);
		};

		let mut password_hash = [0u8; HASHED_PASSWORD_LEN];

		pbkdf2::derive(
			PBKDF2_ALGORITHM,
			PBKDF2_ITERATIONS,
			&salt,
			&client_hash,
			&mut password_hash,
		);

		return Ok::<PasswordHashInfo, ServiceError>(PasswordHashInfo {
			iteration_count: PBKDF2_ITERATIONS,
			salt: salt.to_vec(),
			password_hash_final: password_hash.to_vec(),
		});
	})
	.await
	.map_err(|_| {
		ServiceError::InternalServerError(
			"Failed to run PBKDF2 in a new thread".to_string(),
		)
	})
}

const CREATE_USER_QUERY: &str = r#"
    INSERT INTO accounts
    (
        user_id,
        email,
        first_name,
        last_name,
        iteration_count,
        salt,
        password_hash,
        created_at
    )
    VALUES
    (
        $1::UUID,           --user_id
        $2::VARCHAR(355),   --email
        $3::VARCHAR(100),   --first_name
        $4::VARCHAR(100),   --last_name
        $5::INT,            --iteration_count
        $6::BYTEA,          --salt,
        $7::BYTEA,          --password_hash,
        $8::DATE            --created_at
    )
    ON CONFLICT DO NOTHING
    RETURNING user_id, email;
"#;

async fn create_account_if_not_exists(
	client: &Client,
	request_info: &RegistrationRequest,
	password_hash_info: &PasswordHashInfo,
) -> Result<(Uuid, String), ServiceError> {
	let statement = client.prepare(CREATE_USER_QUERY).await.unwrap();
	let uuid = Uuid::new_v4();
	let date = chrono::Utc::today().naive_utc();
	let iteration_count = password_hash_info.iteration_count.get() as i32;

	let rows = client
		.query(
			&statement,
			&[
				&uuid,
				&request_info.email,
				&request_info.first_name,
				&request_info.last_name,
				&iteration_count,
				&password_hash_info.salt,
				&password_hash_info.password_hash_final,
				&date,
			],
		)
		.await
		.map_err(|e| ServiceError::InternalServerError(e.to_string()))?;

	if rows.is_empty() {
		// We did not successfully create a new account with the provided email address. An account
		// with the given email address already exists.
		Err(ServiceError::Conflict(format!(
			"An account with the given email address {} already exists",
			&request_info.email
		)))
	} else {
		// We successfully created a new account with the given email address.
		let (user_id, email) = (rows[0].get(0), rows[0].get(1));
		Ok((user_id, email))
	}
}

fn make_success_response(user_id: &Uuid, email: &str) -> HttpResponse {
	let message = json!({
		"message": format!("Account with email {} successfully created", email),
		"data": {
			"user_id": user_id,
			"email": email
		}
	});

	HttpResponse::Created().json(message)
}
